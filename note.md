# 笔记

## session_write_start()
在session操作完成后解除session锁定，避免浪费服务器资源，解决高并发下依赖session的请求由于session资源锁定导致响应时间比较长
## interface与abstract区别
https://www.jianshu.com/p/bc59e250f59f

https://www.ziruchu.com/art/59

## 数据库分库、分表、分区

### 分库

解决单台数据库的并发访问量

策略：id取模、根据业务区分

问题：跨库事务处理问题

### 分表

解决单表海量数据问题

#### 水平分表

策略：id取模（若不为整数先hash）、merge存储引擎

问题：

1、跨表无法连接查询

2、数据持续增长、新增分表时数据需要重新排列（1、先估算总数据量；2、表分区）

#### 垂直分表

策略：将大数据量且不常访问的字段存储到新表中

拆分标准考虑：

1、表体积大于2G且超过一千万行

2、表中包含text、blob、varchar(1000)等大字段

#### 分库分表同时实现

策略：

中间变量=id%(库总数*表总数)

库id=取整（中间变量/表总数）

表id=中间变量%表总数

### 分区

把一张表的数据分成N个区块，在逻辑上看最终只是一张表，但底层是由N个物理区块组成

适用：

数据量较大，并发不大的情况

* range，枚举范围

* hash，

* linear hash，线性hash，新增分区不需要变换原数据分区位置

* list，枚举取值

* key，hash分区的增强
## 聚簇索引与非聚簇索引

  ### 聚簇索引

将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据。

聚簇索引是物理索引，数据表就是按顺序存储的，物理上是连续的。

聚簇索引只可能是主键，或者所有组成唯一键的所有列都为NOT NULL的第一个唯一索引，或者隐式创建的聚簇索引（6字节）

#### 优点

行数据和叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了Buffer中，再次访问的时候，会在内存中完成访问，不必访问磁盘。

减少了当出现行移动或者数据页分裂时辅助索引的维护工作，使用主键值当作指针会让辅助索引占用更多的空间，换来的好处是InnoDB在移动行时无须更新辅助索引中的这个"指针"。

取出一定范围数据的时候，使用用聚簇索引

二级索引需要两次索引查找，而不是一次才能取到数据，因为存储引擎第一次需要通过二级索引找到索引的叶子节点，从而找到数据的主键，然后在聚簇索引中用主键再次查找索引，再找到数据

可以把相关数据保存在一起。例如实现电子邮箱时，可以根据用户 ID 来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘 I/O。

#### 缺点

维护索引很昂贵，特别是插入新行或者主键被更新导至要分页(page split)的时候。建议在大量插入新行后，选在负载较低的时间段，通过OPTIMIZE TABLE优化表，因为必须被移动的行数据可能造成碎片。
如果表因为使用UUId（随机ID）作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有比全表扫描更慢。

### 非聚簇索引

将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置

### tips

涉及到大数据量的排序、全表扫描、count之类的操作的话，还是MyISAM占优势些，因为索引所占空间小，这些操作是需要在内存中完成的

### mysql索引类型

#### b-tree

底层使用的是B+Tree这种数据结构来存储数据

##### 特点

* B-tree索引可以加快数据的查询速度。存储引擎不需要进行全表扫描来获得需要的数据，取而代之的是从索引的根节点开始进行搜索。然后根据指针逐层向下查找，通过比较节点页的值和有目标值就可以找到合适的指针进入下层节点，而这些指针实际上定义了子节点页中值的上限和下限。

* B-tree索引更适合进行范围查询。B-tree对索引是顺序组织存储的，所以就很适合进行查找范围数据。

##### 适用场景

* 全值匹配的查询
  指的是和索引中的所有列进行匹配，比如查询字段 name = ‘tom’;

* 匹配最左前缀的查询。比如为ａ列和ｂ列设置联合索引，只要联合索引的第一列（ａ列）符合查询条件，索引就会被用到，若只是第二列（ｂ列）符合条件则不会被用到该索引。

* 匹配列前缀的查询。只匹配某一列的值的开头部分　

* 匹配范围值

* 精准匹配某一列并范围匹配另外一列　
  只访问索引的查询。在这里指的就是覆盖索引，即只需要访问索引，而无需访问数据行　　

* 用于查询中的order by操作
  索引树中的节点是有序的。一般来说，若B-Tree可以按照某种方式查找到该值，那么也可以用这种方式用于排序。所以，如果 order by子句中满足前面列出的几种查询类型，则这个索引也可以满足对应的排序需求

##### 不适用场景
* 若不是按照索引的最左列开始查找，则无法使用该索引
比如建立联合索引（name 、phone_num），若搜索phone_num则无法使用该索引　　
* 使用索引时，不能跳过索引中的列
比如建立联合索引（name 、phone_num 、addr），若搜索name和addr 则无法使用该索引只能使用那么过滤
* not in 和 <> 操作无法使用该索引
* 若查询中有某个列的范围查询，则其右边的所有列都无法使用索引

#### hash

在MySQL的存储引擎中，MyISAM不支持哈希索引，而InnoDB中的hash索引是存储引擎根据B-Tree索引自建的

##### 特点
* 等值查找速度很快
* hash索引是基于hash表实现的，只有查询条件精确匹配hash索引中的所有列的时候，才能用到hash索引
* 对于hash索引中的所有列，存储引擎都会为每一行计算一个hash码，hash索引中存储的就是hash码。
* hash索引包括键值、hash码和指针
  因为hash索引本身只需要存储对应的hash值，所以索引的结构十分紧凑，这也让hash索引查找的速度非常快
##### 限制
* Hash索引必须进行二次查找
使用哈希索引两次查找，第一次找到相应的行，第二次读取数据，但是被频繁访问到的行一般会缓存在内存中，这点对数据库性能的影响不大
* hash索引不能用于外排序
hash索引存储的是hash码而不是键值，所以无法用于外排序
* hash索引不支持部分索引查找也不支持范围查找
只能用到等值查询，不能范围和模糊查询　
* hash索引中的hash码的计算可能存在hash冲突
当出现hash冲突的时候，存储引擎必须遍历整个链表中的所有行指针，逐行比较，直到找到所有的符合条件的行，若hash冲突很多的话，一些索引的维护代价机会很高，所以说hash索引不适用于选择性很差的列上（重复值很多）

## 数据库事务
### 事务的特征：ACID
原子性（Atomicity）一组DML语句要么全部成功要么全部失败
一致性（Consistency） 事务必须由一个状态到另一个状态
隔离性（Isolation） 多个事务之间能够根据事务的隔离级别表现不同
持久性（Durability） 提交后的事务，一旦提交，它对数据库中的数据修改是永久性的

### 事务的隔离级别

| 隔离级别                   | 脏读 | 不可重复读 | 幻读               | 加锁读        |
| :------------------------- | ---- | ---------- | ------------------ | ------------- |
| 读未提交(Read uncommitted) | o    | o          | o                  | 不加锁        |
| 读已提交(Read committed)   | x    | o          | o                  | 不加锁        |
| 可重复读(Repeatable read)  | x    | x          | o(mysql不会出现 x) | 不加锁        |
| 可串行读(Serializable)     | x    | x          | x                  | 加锁 (全表锁) |

脏读：当某个客户端查询出了另外一个事务还没有提交的修改数据，即为脏读。
不可重复读：[同一查询]在[同一事务]中多次进行，由其它提交事务所做的修改或删除，每次返回不同的的结果集，此时发生非重复读。
幻读：[同一查询]在[同一事务]中多次进行，由于其它提交事务(事务可能没提交)所做的插入操作，每次返回不同的结果集，此时发生幻读。

## redis与memcached区别
1. 内存管理机制
Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。在Redis中，并不是所有的数据都一直存储在内存中的。当物理内存用完时，Redis可以将一些很久没用到的value交换到磁盘。Redis支持通过RDB与AOF的方式保存数据实现数据持久化。

2. 数据操作不同
Redis支持多种数据类型，如string、list、sort、hash等，Memcached只支持简单key-value结构的数据

3. 性能不同
由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis

4. 集群管理不同
Memcached本身并不支持分布式，因此只能在客户端通过像一致性哈希这样的分布式算法来实现Memcached的分布式存储。相较于Memcached只能采用客户端实现分布式存储，Redis更偏向于在服务器端构建分布式存储。

