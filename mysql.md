# 三范式

第一范式：1NF是对属性的原子性约束，要求属性具有原子性，不可再分解；
第二范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性；
第三范式：3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。

# 主键、外键和索引的区别
## 定义
主键–唯一标识一条记录，不能有重复的，不允许为空
外键–表的外键是另一表的主键, 外键可以有重复的, 可以是空值
索引–该字段没有重复值，但可以有一个空值

## 作用
主键–用来保证数据完整性
外键–用来和其他表建立联系用的
索引–是提高查询排序的速度

## 个数
主键，主键只能有一个
外键，一个表可以有多个外键
索引，一个表可以有多个唯一索引

# MyISAM与InnoDB

## 锁差异

myisam 表级锁 适用于大量读写

innodb 行级锁，支持事务 适用于大量写与更新

## 数据库文件

myisam（堆表） 表结构(.frm)+索引(.MYI)+数据(.MYD)	,采用B+Tree，但叶节点存储数据地址

innodb（索引组织表）   表结构(.frm)+表空间(.idb)	索引与数据放在一起，一般采用B+Tree，叶节点存储主键与数据

## 索引差别

myisam 可以无索引，自增列必须为索引一部分，所有索引指向数据地址

innodb 如果没有设定主键或者非空唯一索引，会默认生成6字节用户不可见字段作为索引，自增列必须为索引第一部分。数据为主索引的一部分，附加索引指向主索引地址

## count

myisam有保存表的总行数

innodb需要扫描全表

注：若使用限制条件where，两者都会扫描全表

# 数据库事务

## 事务的特征：ACID

原子性（Atomicity）一组DML语句要么全部成功要么全部失败
一致性（Consistency） 事务必须由一个状态到另一个状态
隔离性（Isolation） 多个事务之间能够根据事务的隔离级别表现不同
持久性（Durability） 提交后的事务，一旦提交，它对数据库中的数据修改是永久性的

## 事务的隔离级别

| 隔离级别                             | 脏读 | 不可重复读 | 幻读               | 加锁读        |
| :----------------------------------- | ---- | ---------- | ------------------ | ------------- |
| 读未提交(Read uncommitted)           | o    | o          | o                  | 不加锁        |
| 读已提交(Read committed)             | x    | o          | o                  | 不加锁        |
| 可重复读(Repeatable read),Innodb默认 | x    | x          | o(mysql不会出现 x) | 不加锁        |
| 可串行读(Serializable)               | x    | x          | x                  | 加锁 (全表锁) |

脏读：当某个客户端查询出了另外一个事务还没有提交的修改数据，即为脏读。
不可重复读：[同一查询]在[同一事务]中多次进行，由其它提交事务所做的修改或删除，每次返回不同的的结果集，此时发生非重复读。
幻读：[同一查询]在[同一事务]中多次进行，由于其它提交事务(事务可能没提交)所做的插入操作，每次返回不同的结果集，此时发生幻读。

# Mysql字段优化

## char与varchar

char：定长，效率高，一般用于固定长度的表单提交数据存储，例如：身份证号，手机号，电话，密码等varchar：不定长，效率偏低

当保存char值时，在它们的右边填充空格以达到指定的长度。当检索到CHAR值时，尾部的空格被删除掉。

varchar类型的实际长度是它的值的实际长度+1,这一个字节用于保存实际使用了多大的长度。

## float、double、decimal

Mysql中将小数类型分为两类：浮点型和定点型
浮点型之所以能够存储较大的数值（不精确），原因就是利用存储数据的位来存储指数，但有可能丢失精度，数据有可能不那么准确

float  单精度浮点数，系统提供4个字节用来存储数据，但是能表示的数据范围比整型大的多，大概是10^38；只能保证大概7位数左右的精度

double 双精度浮点数，系统用8个字节来存储数据，表示的范围更大，10^308次方，但是精度也只有15位左右。

decimal 定点数，能够保证数据精确的小数（小数部分可能不精确，超出长度会四舍五入），整数部分一定精确，Decimal(M,D)：M表示总长度，最大值不能超过65，D代表小数部分长度，最长不能超过30。

# Mysql查询优化

![avatar](http://mmbiz.qpic.cn/mmbiz_png/tibrg3AoIJTtt5WD7PStDP8xn9FCAqN0Hc2PLZUxDUsebS6dLW6fKHyGVfosuX3XeLwClNP3GWNGvw0dicv8mficw/0?wx_fmt=png)

MySQL客户端/服务端通信协议是“半双工”的：在任一时刻，要么是服务器向客户端发送数据，要么是客户端向服务器发送数据，这两个动作不能同时发生。

服务器响应给用户的数据通常会很多，由多个数据包组成。但是当服务器响应客户端请求时，客户端必须完整的接收整个返回结果，而不能简单的只取前面几条结果，然后让服务器停止发送。因而在实际开发中，尽量保持查询简单且只返回必需的数据，减小通信间数据包的大小和数量是一个非常好的习惯，这也是查询中尽量避免使用SELECT *以及加上LIMIT限制的原因之一，特别是应用服务与mysql服务不在同一服务器上时。

## 查询缓存

避免在查询中使用非确定性函数，如Now()和RAND()等.由于函数的返回结果可能会改变，MySQL会禁用该查询的查询缓存。

```
$r = mysql_query("SELECT username FROM user WHERE signup_date >= CURDATE()");
 
$today = date("Y-m-d");
$r = mysql_query("SELECT username FROM user WHERE signup_date >= '$today'");
```

## EXPLAIN 关键字

explain显示了mysql如何使用索引来处理select语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句。

- select-type 表示了查询的类型

  SIMPLE，表示此查询不包含 UNION 查询或子查询
  PRIMARY， 表示此查询是最外层的查询
  UNION，表示此查询是 UNION 的第二或随后的查询
  DEPENDENT UNION，UNION 中的第二个或后面的查询语句, 取决于外面的查询
  UNION RESULT，UNION 的结果
  SUBQUERY，子查询中的第一个 SELECT
  DEPENDENT SUBQUERY， 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.

- table：显示这一行的数据是关于哪张表的

- type：这是重要的列，显示连接使用了何种类型，是较为重要的一个指标。

  结果值从好到坏依次是：system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL,，一般来说，得保证查询至少达到range级别，最好能达到ref。

  system:const连接类型的特殊情况，表只有一行

  const:用于将 "主键" 或 "唯一" 索引的所有部分与常量值进行比较
  eq_ref:在连接中，MYSQL在联合查询时使用了索引为主键或惟一键
  ref:这个连接类型只有在查询使用了不是惟一或主键的键或者是这些类型的部分（比如，利用最左边前缀）时发生。
  range:这个连接类型使用索引返回一个范围中的行，比如使用>或<查找东西时发生的情况
  index: 这个连接类型对前面的表中的每一个记录联合进行完全扫描（比ALL更好，因为索引一般小于表数据）
  ALL:这个连接类型对于前面的每一个记录联合进行完全扫描，这一般比较糟糕，应该尽量避免

- possible_keys：显示可能应用在这张表中的索引。

- key： 实际使用的索引。

- key_len：使用的索引的长度。在不损失精确性的情况下，长度越短越好

- ref：显示索引的哪一列被使用了，如果可能的话，是一个常数

- rows：MYSQL认为必须检查的用来返回请求数据的行数

- Extra：关于MYSQL如何解析查询的额外信息。

## LIMIT 1

当你查询表的有些时候，可能知道结果只会有一条结果。在这种情况下，加上 LIMIT 1 可以增加性能。添加后，MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据。比如查询满足某个条件语句的数据是否存在时。

## Join索引

如果应用程序包含许多联接查询，则需要确保在两个表上都对所连接的列进行索引。此外，被连接的列需要相同的类型，对于字符串类型列，甚至字符编码也需要相同的类型。另外，能用inner join的时候，首先使用inner join，因为等值内联返回的数据数码较少，查询效率会高一些

## RAND()命令

谨慎使用RAND()命令，千万不要用来实现随机获取数据操作，因为MySQL必须对表中的每一行执行RAND()操作，然后再对其进行排序，随着数据的增长，瓶颈会呈指数级恶化。

## 拆分大的 DELETE 或 INSERT 语句

如果你需要在执行一个大的DELETE或INSERT查询，你一定把其拆分，使用 LIMIT条件是一个好的方法，这两个操作是可能会锁表的（非行级锁，可能会是区间锁，然后导致死锁产生），表一锁住了，别的操作都进不来了。 

# 聚簇索引与非聚簇索引

## 聚簇索引

将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据。

聚簇索引是物理索引，数据表就是按顺序存储的，物理上是连续的。

聚簇索引只可能是主键，或者所有组成唯一键的所有列都为NOT NULL的第一个唯一索引，或者隐式创建的聚簇索引（6字节）

### 优点

行数据和叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了Buffer中，再次访问的时候，会在内存中完成访问，不必访问磁盘。

减少了当出现行移动或者数据页分裂时辅助索引的维护工作，使用主键值当作指针会让辅助索引占用更多的空间，换来的好处是InnoDB在移动行时无须更新辅助索引中的这个"指针"。

取出一定范围数据的时候，使用用聚簇索引

二级索引需要两次索引查找，而不是一次才能取到数据，因为存储引擎第一次需要通过二级索引找到索引的叶子节点，从而找到数据的主键，然后在聚簇索引中用主键再次查找索引，再找到数据

可以把相关数据保存在一起。例如实现电子邮箱时，可以根据用户 ID 来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘 I/O。

### 缺点

维护索引很昂贵，特别是插入新行或者主键被更新导至要分页(page split)的时候。建议在大量插入新行后，选在负载较低的时间段，通过OPTIMIZE TABLE优化表，因为必须被移动的行数据可能造成碎片。
如果表因为使用UUId（随机ID）作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有比全表扫描更慢。

## 非聚簇索引

将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置

## tips

涉及到大数据量的排序、全表扫描、count之类的操作的话，还是MyISAM占优势些，因为索引所占空间小，这些操作是需要在内存中完成的

## mysql索引类型

### b-tree

底层使用的是B+Tree这种数据结构来存储数据

#### 特点

- B-tree索引可以加快数据的查询速度。存储引擎不需要进行全表扫描来获得需要的数据，取而代之的是从索引的根节点开始进行搜索。然后根据指针逐层向下查找，通过比较节点页的值和有目标值就可以找到合适的指针进入下层节点，而这些指针实际上定义了子节点页中值的上限和下限。
- B-tree索引更适合进行范围查询。B-tree对索引是顺序组织存储的，所以就很适合进行查找范围数据。

#### 适用场景

- 全值匹配的查询
  指的是和索引中的所有列进行匹配，比如查询字段 name = ‘tom’;
- 匹配最左前缀的查询。比如为ａ列和ｂ列设置联合索引，只要联合索引的第一列（ａ列）符合查询条件，索引就会被用到，若只是第二列（ｂ列）符合条件则不会被用到该索引。
- 匹配列前缀的查询。只匹配某一列的值的开头部分　
- 匹配范围值
- 精准匹配某一列并范围匹配另外一列　
  只访问索引的查询。在这里指的就是覆盖索引，即只需要访问索引，而无需访问数据行　　
- 用于查询中的order by操作
  索引树中的节点是有序的。一般来说，若B-Tree可以按照某种方式查找到该值，那么也可以用这种方式用于排序。所以，如果 order by子句中满足前面列出的几种查询类型，则这个索引也可以满足对应的排序需求

#### 不适用场景

- 若不是按照索引的最左列开始查找，则无法使用该索引
  比如建立联合索引（name 、phone_num），若搜索phone_num则无法使用该索引　　
- 使用索引时，不能跳过索引中的列
  比如建立联合索引（name 、phone_num 、addr），若搜索name和addr 则无法使用该索引只能使用那么过滤
- not in 和 <> 操作无法使用该索引
- 若查询中有某个列的范围查询，则其右边的所有列都无法使用索引

### hash

在MySQL的存储引擎中，MyISAM不支持哈希索引，而InnoDB中的hash索引是存储引擎根据B-Tree索引自建的

#### 特点

- 等值查找速度很快
- hash索引是基于hash表实现的，只有查询条件精确匹配hash索引中的所有列的时候，才能用到hash索引
- 对于hash索引中的所有列，存储引擎都会为每一行计算一个hash码，hash索引中存储的就是hash码。
- hash索引包括键值、hash码和指针
  因为hash索引本身只需要存储对应的hash值，所以索引的结构十分紧凑，这也让hash索引查找的速度非常快

#### 限制

- Hash索引必须进行二次查找
  使用哈希索引两次查找，第一次找到相应的行，第二次读取数据，但是被频繁访问到的行一般会缓存在内存中，这点对数据库性能的影响不大
- hash索引不能用于外排序
  hash索引存储的是hash码而不是键值，所以无法用于外排序
- hash索引不支持部分索引查找也不支持范围查找
  只能用到等值查询，不能范围和模糊查询　
- hash索引中的hash码的计算可能存在hash冲突
  当出现hash冲突的时候，存储引擎必须遍历整个链表中的所有行指针，逐行比较，直到找到所有的符合条件的行，若hash冲突很多的话，一些索引的维护代价机会很高，所以说hash索引不适用于选择性很差的列上（重复值很多）

# 数据库分库、分表、分区

## 分库

解决单台数据库的并发访问量

策略：id取模、根据业务区分

问题：跨库事务处理问题

## 分表

解决单表海量数据问题

### 水平分表

策略：id取模（若不为整数先hash）、merge存储引擎

问题：

1、跨表无法连接查询

2、数据持续增长、新增分表时数据需要重新排列（1、先估算总数据量；2、表分区）

### 垂直分表

策略：将大数据量且不常访问的字段存储到新表中

拆分标准考虑：

1、表体积大于2G且超过一千万行

2、表中包含text、blob、varchar(1000)等大字段

### 分库分表同时实现

策略：

中间变量=id%(库总数*表总数)

库id=取整（中间变量/表总数）

表id=中间变量%表总数

## 分区

把一张表的数据分成N个区块，在逻辑上看最终只是一张表，但底层是由N个物理区块组成

适用：

数据量较大，并发不大的情况

- range，枚举范围
- hash，
- linear hash，线性hash，新增分区不需要变换原数据分区位置
- list，枚举取值
- key，hash分区的增强